\subsection{Sistema a resolver}

Como mencionamos en la introducción, comenzamos armando el sistema de la Matriz de Colley basados en el paper de Colley\footnote{''\textbf{The Colley Matrix Explained}:Wesley N. Colley''}, este método está basado en la Regla de Laplace de sucesos y solo se requiere conocer un historial de partidos. 
El método de \textbf{CMM} propone construir una matriz C $\in$ $ R^{nxn}$ , un vector b $\in$ $ R^n$ tal que el ranking r $\in$ $R^n$ buscado sea la solución al sistema Cr=b.
Para esto utiliza, que dado un equipo $i$, la cantidad total de partidos jugados por este equipo como $n_i$, sabiendo que tuvo $w_i$ victorias el equipo, análogamente $l_i$ los partidos perdidos y $n_{i,j}$ la cantidad de partidos jugados entre el equipo $i$ y $j$, para finalmente definir a la matriz C como: 

\[ C_{i,j} =
    \begin{cases}
        -n_{i,j}       & \quad \text{si }  \text{i $\neq$ j}\\
        2+n_i & \quad \text{si } \text{ i = j }\\
    \end{cases}
$$
  $$  \]
                    
y $b_i$ = 1 +  ($w_i$ - $l_i$) / 2.

Esta matriz tiene la particularidad de ser simetrica y definida positiva,siendo condicion necesaria para encontrar la factorizaci\'on de cholesky sobre esta matriz, ademas de factorizaci\'on LU.

Ambos m\'etodos, Eliminaci\'on gaussiana y Factorizaci\'on de cholesky, combinadas con otras t\'ecnicas de remplazo nos permitiran resolver el sistema presentado previamente.

La principal fortaleza de este método es que es útil para obtener rankings en torneos donde los participantes no juegan la misma cantidad de partidos, lo cual 
podrias hacer una an\'alisis m\'as exhaustivo sobre cada uno de los partidos jugados y como afecta esto en todo un torneo,
además de que al armar el sistema en base a los resultados pasados, da relevancia al calendario de juegos de cada participante. 
Luego se intentará demostrar en la sección de experimentos, utilizando esta tecnica importa contra quien se gana y contra quien se pierde.

Por otro lado las desventajas que notamos es que no es aplicable a muchos de los deportes es que los empates no pueden ser modelados, adem\'as de que el ranking no toma en cuenta
el margen de victoria de los equipos lo cual en los casos donde hay empate en el ranking podriamos utilizarlos para desempatar.

En cuanto a escalar en este metodo no parece ser muy intuitivo mirando la matriz a simple vista pero nuestra intuici\'on nos dice que importa a quien se le gana, que no es lo mismo ganarle al que esta \'ultimo que ganarle al que esta primero
y en esto nos vamos a basar para realizar nuestras experimentaci\'ones en las secci\'ones de m\'as adelante.
Para esto utilizaremos un algoritmo greedy tomando al equipo que salga \'ultimo en el ranking y haciendolo jugar con otro equipo que este mejor posici\'onado que el , para esto utilizaremos 2 heuristicas distintas
con el fin de obtener una mejor posici\'on, la primera sera contra el inmediato siguiente en el ranking y la otra contra el que este primero, siempre tomando el ranking que resulta luego de cada partido.

Una vez obtenida la \textbf{Matriz de Colley} vamos a  presentar dos técnicas de resoluci\'on del sistema de ecuaci\'ones solicitado.

\subsubsection{Eliminación Gaussiana}
La implementación del algorimo de \textbf{Eliminación Gaussiana} que elegimos es la que se encuentra en el libro \textbf{Burden[1]}.Con el agregado de backwards substitution para 
obtener el vector de la ecuaci\'on Cr=b.

Presentamos un pseudo codigo del algoritmo de eliminaci\'on gaussiana que utilizamos en nuestra implementaci\'on que luego en secci\'ones futuras vamos a detallar.

\begin{algorithm}
    \begin{algorithmic}[1]\parskip=2mm
        \caption{vector Gauss(matriz A, vector b)}
        \STATE{Para k=$1...n-1$}\\
        \STATE{\quad Para i=$1...n-1$}\\
        \STATE{\quad\quad Tomo el elemento $a_{k,k}$ como pivot}\\
        \STATE{\quad\quad Para $j = i+1,...n$}\\
        \STATE{\quad \quad \quad $a_{i,j}  = a_{i,j} - a_{i,j} * (a_{i,k} / a_{k,k})$}\\
        \STATE{\quad \quad \quad $b_{i}  = b_{i} - a_{i,j} * (a_{i,k} / a_{k,k})$}\\
        \STATE{$x_{n} = a_{n,n+1}/a_{n,n}$}\\
        \STATE{para $i=n-1..1$}\\
        \STATE{\quad para $j=i+1..n$}\\
        \STATE{\quad\quad $ sum +=a_{i,j}*x_{j}$}\\
        \STATE{\RETURN x}
    \end{algorithmic}
\end{algorithm}

Para este algoritmo como se puede observar es de complejidad O($n^3$) en el peor caso, ya que en ciclo interno de las posici\'ones 4 a 6 se ejecuta n veces
y el ciclo de las l\'ineas 2 a 6 se ejecuta n veces por lo tanto ya tendriamos $n^2$ iteraci\'ones en el peor caso y finalizando con el ciclo de las l\'ineas 1 a 6 que se ejecuta otras n veces.
Luego en las l\'ineas 7 a 10 se realiza el backgward substitution  que tiene en el peor caso se ejecuta $n^2$ veces.\\
Con lo cual lo que esperamos en nuestros an\'alisis de cantidad de equipos sobre tiempos de en la secci\'on experimentaci\'on es encontrarnos con un grafico de una funci\'on cubica.

\newpage
\subsubsection{Cholesky}

La implementación del algoritmo de factorizaci\'on de cholesky que elegimos al igual que la eliminaci\'on gaussiana es la que se encuentra en el libro \textbf{Burden}.
Agregandole los pasos que mensiona en el libro (pagina 420) para resolver el sistema Cr$=$b.

Este pseudocodigo representa nuestra implementaci\'on sobre la factorizaci\'on de cholesky.

\begin{algorithm}
    \begin{algorithmic}[1]\parskip=2mm
        \caption{vector Cholesky(matriz A, vector b)}
        \STATE{$l_{1,1} = \sqrt{a_{1,1}}$}\\
        \STATE{Para j = 2,...n}
        \STATE{\quad $ l_{j,1} = a_{j,1} / l_{1,1}$}
        \STATE{Para $i = 2,...n-1$}\\
        \STATE{\quad $l_{i,i}  = (a_{i,i} - \sum_{k=1}^{i-1}{l^2_{i,k}}^{1/2})$}\\
        \STATE{\quad Para $j = i+1,...n1$}\\
        \STATE{\quad\quad $l_{j,i}  = (a_{j,i} - \sum_{k=1}^{i-1}{l_{j,k} l_{i,k}} / l_{i,i})$}\\
        \STATE{$l_{n,n}  = (a_{n,n} - \sum_{k=1}^{n-1}{l^2_{n,k}}$)}\\
        \STATE{$y_1=b_1 l_{1,1}$}\\
        \STATE{Para i$=$2..n}\\
        \STATE{\quad Para j$=$1..i-1}\\
        \STATE{\quad\quad sum=$l_{i,j}*y_j$}\\
        \STATE{\quad\quad $y_i=(b_i-sum) \ l_{i,i}$}\\
        \STATE{$x_n=y_n \ l_{n,n}$}\\
        \STATE{Para i$=$n-1..1}\\
        \STATE{\quad Para j$=$i+1..n}\\
        \STATE{\quad\quad sum$=l_{i,j}*x_j$}\\
        \STATE{\quad\quad $x_i=(y_i-sum)\ l_{i,i}$}
        \STATE{\RETURN x}
    \end{algorithmic}
\end{algorithm}
Para las l\'ineas 2-3 se puede ver que se ejecuta n veces.
Dentro de esta algoritmo en las l\'ineas 4-7 se realizan 3 ciclos donde en el peor caso se obtienen $n^3 $ ciclos.
Por \'ultimo para las l\'ineas 10 - 13 y 15 -18 se realizan 2 ciclos de n iteracines cada uno teniendo como total $n^2$ iteraci\'ones.
Con lo cual lo que esperamos en nuestros an\'alisis de tiempos por cantidad de equipos es que obtengamos una cubica.

\newpage
\subsection{Porcentaje de Victorias}

Por otro lado analizaremos otra tecnica en base a el \textbf{Porcentaje de Victorias} que a lo largo del análisis denominaremos \textbf{WP} que consiste en 
tomar el promedio de partidos ganados sobre partidos jugados.

Esta técnica basicamente analiza la performance de un equipo participante en los partidos jugados en base a partidos ganados. 	

En este caso el score de un equipo no es afectado por la cantidad de partidos y resultados obtenidos de los demás participantes, pero esto si afecta su posición final en el ranking. 

Esta técnica a priori no aporta mucha informaci\'on respectoa la posibilidad de victoria en el siguiente encuentro y tampoco considera el ranking del rival enfrentado.
Ya que todos los partidos valen lo mismo. 

La implementación consiste en calcular: $\sum_{i=1}^n{} \frac{G_i}{T}$ 

Donde \textbf{n} es la cantidad de partidos jugados, \textbf{G} corresponde a partidos ganados y \textbf{T} al total de partidos jugados. \\
